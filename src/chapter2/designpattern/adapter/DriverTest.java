package chapter2.designpattern.adapter;

import org.junit.Test;

/**
 * 适配器模式
 */
public class DriverTest {

    /**
     * 适用场景
     * 1需要使用的类的接口与需要的接口类型不匹配
     * 2需要创建一个可重用的类，它可以与不相关的或不可预见的类进行协作，也就是说， 类不一定具有兼容的接口
     * 3需要使用几个现有的子类，但是通过子类化每个子类来调整它们的接口是不切实际的。 对象适配器可以调整其父类的接口。
     * <p>
     * 类适配器和对象适配器的区别
     * <p>
     * 1类适配器的适配功能是通过被适配类（接口）的一个对象间接完成的。因此，类适配器不能无法 对被适配类的所有子类进行适配
     * 2类适配器重写了被适配类（接口）的方法，所以，类适配器可以看做被适配类（接口）的一个子类
     * 3类适配器一般只需持有一个被适配类（接口）的对象，并不需要额外的对被适配类（接口）的引用
     * 4对象适配器可以和多个被适配类（接口）的对象协同工作——即被适配类（接口）本身及其所有子类。适配器也可以一次为所有的被适配类（接口）添加自定义的功能。
     * 5对象适配器使得重写被适配类（接口）的方法变成了不可能，这时需要的是被适配类（接口）的子类，而不是被适配类（接口）本身
     */
    @Test
    public void driveTest() {
        //
        BusAdapter busAdapter = new BusAdapter();
        busAdapter.drive();


    }
}
